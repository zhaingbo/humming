C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\bin\main.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE usr\main.c BROWSE INCDIR(.\usr) DEBUG OBJECTEXTEND PRINT(.\listing\main.lst
                    -) OBJECT(.\bin\main.obj)

line level    source

   1          /**************************************************************************
   2           *
   3           *   Copyright (c) 2016 www.bjfz.cc. All rights reserved.
   4           *
   5           * @file main.c
   6           *
   7           * 
   8           *
   9           * @author Author email
  10           *
  11           *************************************************************************/
  12          
  13          
  14          //*************************************2015214 *********************
  15          //Ӳ
  16          //:1S/3.7V Ƽ300-650mAh   500mahϵĵƼװڱ
  17          ///:720ı/59MM
  18          //   رԵĿıΪԱ ڽʢ 720ı ҵĵڱ򣬳
             -еPID
  19          //             ԵΪԱ ƽ۵ 59MMֱ 1mm׾ ҵڱ
             -򣬳еPID
  20          //MCU IAP15W4K61S4@28.000MHZ  (B棡A浥ƬԲʺϣ)
  21          //ر˵ĿǰֻʺIAPϵеĵƬIAPƬʹ޸EEPROMдַ
  22          //ǼٶȼƣMPU-6050
  23          //оƬ:NRF24L01
  24          //MOS:AO3400
  25          //ѹ:BL8530
  26          //3.3Vѹ:ME6219C-33-M5G
  27          //ؿڱ:1K
  28          //ܳߴ:94mm*94mm
  29          
  30          //ʧĵط
  31          //MOSܱõФػŴλãȫӰʹãС᲻ФػС
  32          
  33          //
  34          //̬㣺Ԫ
  35          //˲˲From ¹Դᣩ
  36          //PIDPID ⻷PI,ڻPID
  37          
  38          //ݶ˵
  39          //data 51ƬƬRAMǰ128ֽRAM ACCдٶ
  40          //idata ƬRAMǰ256ֽڵRAM data ָģʽ ʺָ
  41          //pdata ⲿչRAMǰ256ֽڵRAM Ҫ 裡
  42          //xdata ⲿչRAM DPTR
  43          
  44          #include "timer.h"
  45          
  46          #include "app/imu.h"
  47          #include "app/stc15w4kpwm.h"
  48          
  49          #include "driver/eeprom.h"
  50          #include "driver/mpu6050.h"
  51          #include "driver/nrf24l01.h"
  52          #include "driver/usart.h"
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 2   

  53          
  54          #include "inc/common.h"
  55          
  56          #include <math.h>
  57          
  58          // ************************************************************************
  59          float XE = 0, YE = 0;            //ǶΪƯһӲɵģʲֵдEEPROM
             -ӦʹãƯӦ
  60          //λǷʱ
  61          
  62          // ű仯ٶȿƣĻٱ仯ʱʧٷתGG
  63          float throttle = 0;
  64          
  65          // ߴ/
  66          uint8_t ich1 = 0, ich2 = 0, ich3 = 0, ich4 = 0, ich5 = 0, ich6 = 0;
  67          
  68          // ٶȲ
  69          int speed0 = 0, speed1 = 0, speed2 = 0, speed3 = 0, V = 0;
  70          int PWM0 = 0, PWM1 = 0, PWM2 = 0, PWM3 = 0; //PWMģĲ
  71          int g_x = 0, g_y = 0, g_z = 0;    //ǽ
  72          char a_x = 0, a_y = 0;            //ǶȽ
  73          /* unsigned char TxBuf[20] = {0}; */
  74          uint8_t RxBuf[20] = {0};
  75          
  76          double PID_x = 0, PID_y = 0, PID_z = 0; //PID
  77          float FR1 = 0, FR2 = 0, FR3 = 0; //charתΪfloat
  78          
  79          //*****************ǶȲ*************************************************
  80          double  Gyro_y     = 0, Gyro_x = 0, Gyro_z = 0; //Yݴ
  81          double  Accel_x    = 0, Accel_y = 0, Accel_z = 0;       //Xٶֵݴ
  82          double  Angle_ax   = 0, Angle_ay = 0, Angle_az = 0;     //ɼٶȼļٶ()
  83          double  Angle_gy   = 0, Angle_gx = 0, Angle_gz = 0;     //ɽٶȼĽ(Ƕ)
  84          double  AngleAx    = 0, AngleAy = 0;    //Ǻŷ
  85          double  Angle      = 0, Angley = 0;     //Ԫŷ
  86          double  Anglezlate = 0;         //Z
  87          double  Ax                 = 0, Ay = 0; //ңĽǶ
  88          
  89          //****************̬PID*********************************************
  90          float Out_PID_X = 0, Last_Angle_gx = 0; //⻷PI  һ
  91          float Out_XP = 35, Out_XI = 0.01, ERRORX_Out = 0; //⻷P  ⻷I  ⻷
  92          //ڻP  ڻI   ڻD  ڻ
  93          float In_XP = 0.4, In_XI = 0.01, In_XD = 9, ERRORX_In = 0; 
  94          
  95          float Out_PID_Y = 0, Last_Angle_gy = 0;
  96          float Out_YP = 35, Out_YI = 0.01, ERRORY_Out = 0;
  97          float In_YP = 0.4, In_YI = 0.01, In_YD = 9, ERRORY_In = 0;
  98          
  99          float ZP = 5.0, ZD = 4.0; //ƵP D
 100          
 101          int16_t lastR0 = 0, ZT = 0; //һRxBuf[0](RxBuf[0]ڲϱ䶯)   ״̬ʶ
 102          int16_t i = 0;
 103          
 104          void Angle_Calculate() interrupt 1
 105          {
 106   1              // ֹű仯ʧ
 107   1              if (throttle<RxBuf[4]&&(RxBuf[4]-throttle) <= 2) {
 108   2                      throttle++;
 109   2                      throttle++;
 110   2              } else if (throttle>RxBuf[4]&&(throttle-RxBuf[4]) <= 2) {
 111   2                      throttle--;
 112   2                      throttle--;
 113   2              } else {
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 3   

 114   2                      throttle = RxBuf[4];
 115   2              }
 116   1      
 117   1              if (RxBuf[1] > FR1) {
 118   2                      FR1 += 0.2;
 119   2              } else if (RxBuf[1] < FR1) {
 120   2                      FR1 -= 0.2;
 121   2              }
 122   1      
 123   1              if (RxBuf[2] > FR2) {
 124   2                      FR2 += 0.2;
 125   2              } else if (RxBuf[2] < FR2) {
 126   2                      FR2 -= 0.2;
 127   2              }
 128   1      
 129   1              throttle = (float)RxBuf[4] * 3 / 4;
 130   1      
 131   1              if (throttle > 100) { //Ŵ100 ʼ
 132   2                      if (RxBuf[0] == lastR0) { //RxBuf[0]ûյ ʸ
 133   3                              ZT++;  //״̬ʶ+1
 134   3      
 135   3                              if (ZT > 128) {
 136   4                                      ZT = 128;   //״̬ʶ1281ûյݣʧر
 137   4                              }
 138   3                      } else {
 139   3                              ZT = 0;
 140   3                      }
 141   2              } else {
 142   2                      ZT = 0;   //յź˳ʧر
 143   2              }
 144   1      
 145   1              if (ZT == 128) {
 146   2                      throttle = 101;    //ʧر Ϊ1һ㣬½
 147   2                      RxBuf[1] = 128;
 148   2                      RxBuf[2] = 128;
 149   2              }
 150   1      
 151   1              lastR0 = RxBuf[0];
 152   1              i++;
 153   1      
 154   1              if (i == 130) {
 155   2                      i = 129;
 156   2              }
 157   1      
 158   1              Accel_y = GetData(ACCEL_YOUT_H);        //ȡ6050
 159   1              Accel_x = GetData(ACCEL_XOUT_H);
 160   1              Accel_z = GetData(ACCEL_ZOUT_H);
 161   1              Gyro_x  = GetData(GYRO_XOUT_H) - g_x;
 162   1              Gyro_y  = GetData(GYRO_YOUT_H) - g_y;
 163   1              Gyro_z  = GetData(GYRO_ZOUT_H) - g_z;
 164   1      
 165   1              Last_Angle_gx = Angle_gx; //һνٶ
 166   1              Last_Angle_gy = Angle_gy;
 167   1              Angle_ax = (Accel_x)    / 8192; //ٶȴ
 168   1              Angle_az = (Accel_z)    / 8192; //ٶ +-4g/S
 169   1              Angle_ay = (Accel_y)    / 8192; //תϵ8192LSB/g
 170   1              Angle_gx = (Gyro_x)             / 65.5; //Ǵ
 171   1              Angle_gy = (Gyro_y)             / 65.5; // +-500/S
 172   1              Angle_gz = (Gyro_z)             / 65.5; //תϵ65.5LSB/
 173   1              //***********************************Ԫ**************************
 174   1              // 0.174533ΪPI/180 ĿǽǶת
 175   1              IMUupdate(deg2rad(Angle_gx), deg2rad(Angle_gy), deg2rad(Angle_gz),
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 4   

 176   1                                Angle_ax, Angle_ay, Angle_az);
 177   1      
 178   1              //********************ǺֱӽԹȽԪ㾫׼*****************
 179   1              // 180/PI ĿǻתǶ
 180   1              AngleAx = rad2deg(atan(Angle_ax / sqrt(sq(Angle_ay) + sq(Angle_az))));
 181   1              AngleAy = rad2deg(atan(Angle_ay / sqrt(sq(Angle_ax) + sq(Angle_az))));
 182   1      
 183   1              //**************Xָ*************************************************
 184   1              FR1 = ((fp32)RxBuf[1] - 128) / 7;//charתΪfloatԱ
 185   1              Ax = Angle - FR1 - a_x;                 //ǶȿǶ
 186   1      
 187   1              if (throttle > 20) {
 188   2                      ERRORX_Out += Ax;                       //⻷(Сĳֵʱ)
 189   2              } else {
 190   2                      ERRORX_Out = 0;                         //Сڶֵʱֵ
 191   2              }
 192   1      
 193   1              /* ޷ */
 194   1              ERRORX_Out = constraint(ERRORX_Out, -500, 500);
 195   1              Out_PID_X = Ax*Out_XP + ERRORX_Out*Out_XI; //⻷PI
 196   1      
 197   1              if (throttle > 20) {
 198   2                      ERRORX_In += (Angle_gy - Out_PID_X); //ڻ(Сĳֵʱ)
 199   2              } else {
 200   2                      ERRORX_In = 0; //Сڶֵʱֵ
 201   2              }
 202   1      
 203   1              /* ڻ޷ */
 204   1              ERRORX_In = constraint(ERRORX_In, -500, 500);
 205   1              /* ڻPID */
 206   1              PID_x = (Angle_gy + Out_PID_X) * In_XP +
 207   1                      ERRORX_In * In_XI +
 208   1                      (Angle_gy - Last_Angle_gy) * In_XD;
 209   1              /* PID޷ */
 210   1              PID_x = constraint(PID_x, -1000, 1000);
 211   1      
 212   1              speed0 = 0 - PID_x;
 213   1              speed2 = 0 + PID_x;
 214   1      
 215   1              //**************Yָ*************************************************
 216   1              /* YмΧ113~143ȡֵΧΪ0~255 */
 217   1              if (RxBuf[2] >= 113 && RxBuf[2] <= 143) {
 218   2                      RxBuf[2] = 128;
 219   2              }
 220   1      
 221   1              // charתΪfloatԱ
 222   1              FR2 = ((fp32)RxBuf[2] - 128) / 7.0;
 223   1              Ay = Angley + FR2 - a_y; //ǶȿǶ
 224   1      
 225   1      
 226   1              if (throttle > 20) {
 227   2                      ERRORY_Out += Ay; //⻷(Сĳֵʱ)
 228   2              } else {
 229   2                      ERRORY_Out = 0; //Сڶֵʱֵ
 230   2              }
 231   1      
 232   1              /* Y⻷޷ */
 233   1              ERRORY_Out = constraint(ERRORY_Out, -500, 500);
 234   1              Out_PID_Y = Ay * Out_YP + ERRORY_Out * Out_YI; //⻷PI
 235   1      
 236   1              if (throttle > 20) {
 237   2                      ERRORY_In += (Angle_gx - Out_PID_Y); //ڻ(Сĳֵʱ)
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 5   

 238   2              } else {
 239   2                      ERRORY_In = 0; //Сڶֵʱֵ
 240   2              }
 241   1      
 242   1              /* Yڻ޷ */
 243   1              ERRORY_In = constraint(ERRORY_In, -500, 500);
 244   1              /* ڻPID */
 245   1              PID_y = (Angle_gx + Out_PID_Y) * In_YP +
 246   1                      ERRORY_In * In_YI +
 247   1                      (Angle_gx - Last_Angle_gx) * In_YD;
 248   1      
 249   1              PID_y = constraint(PID_y, -1000, 1000);
 250   1      
 251   1              speed3 = 0 + PID_y;
 252   1              speed1 = 0 - PID_y; //صٶȲ
 253   1      
 254   1              //**************Zָ(ZûҪϴPID)*******************
 255   1              FR3 = ((float)RxBuf[3] - 128) * 1.5;
 256   1              Angle_gz -= FR3;
 257   1              PID_z = (Angle_gz) * ZP + (Angle_gz - Anglezlate) * ZD;
 258   1              Anglezlate = Angle_gz;
 259   1              speed0 = speed0 + PID_z;
 260   1              speed2 = speed2 + PID_z;
 261   1              speed1 = speed1 - PID_z;
 262   1              speed3 = speed3 - PID_z;
 263   1      
 264   1              //*****************ڼߴ*************************************
 265   1              // ˴ɷ6λҪʲôڴ˴޸ļ
 266   1              ich1 = Ax;
 267   1              ich2 = Ay;
 268   1              ich3 = AngleAx;
 269   1              ich4 = AngleAy;
 270   1              ich5 = 0;
 271   1              ich6 = 0;
 272   1      
 273   1              //**************ٶȲPWMģ************************************
 274   1              //ٶȲƣֹPWMΧ0-1000
 275   1              PWM0 = (1000 - throttle * 4 + speed0);
 276   1              PWM0 = constraint(PWM0, 0, 1000);
 277   1      
 278   1              PWM1 = (1000 - throttle * 4 + speed1);
 279   1              PWM1 = constraint(PWM1, 0, 1000);
 280   1      
 281   1              PWM2 = (1000 - throttle * 4 + speed2);
 282   1              PWM2 = constraint(PWM0, 0, 1000);
 283   1      
 284   1              PWM3 = (1000 - throttle * 4 + speed3);
 285   1              PWM3 = constraint(PWM3, 0, 1000);
 286   1      
 287   1              if (throttle >= 10) {
 288   2                      PWM(PWM1, PWM2, PWM0, PWM3);   //1203
 289   2              } else {
 290   2                      PWM(1000, 1000, 1000, 1000);
 291   2              }
 292   1      }
 293          
 294          void main()
 295          {
 296   1              PWMGO();//ʼPWM
 297   1              IAPRead();//ȡǾ
 298   1              InitMPU6050();//ʼMPU-6050
 299   1              Usart_Init();//ʼ
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 6   

 300   1              timer0_init();//ʼʱ
 301   1              RxBuf[1] = 128;
 302   1              RxBuf[2] = 128;
 303   1              RxBuf[3] = 128;
 304   1              RxBuf[4] = 0;
 305   1      
 306   1              while (1) {
 307   2                      Delay(500);
 308   2                      nRF24L01_RxPacket(RxBuf);
 309   2      
 310   2                      if (RxBuf[5] == 1 && i > 128) {
 311   3                              IAP_Gyro();
 312   3                              RxBuf[5] = 0;
 313   3                              EA               = 0;
 314   3                              PWMCKS   = 0x10;
 315   3                              T2L              = 0xEB;
 316   3                              T2H              = 0xFF;
 317   3                              PWM(960, 960, 960, 960);
 318   3                              Delay(60000);           //У׼ϵһ
 319   3                              PWM(1000, 1000, 1000, 1000);
 320   3                              PWMCKS   = 0x00;
 321   3                              EA               = 1;
 322   3                              i                = 0;
 323   3                      }
 324   2      
 325   2                      if (RxBuf[6] == 1 && i > 128) {
 326   3                              IAP_Angle();
 327   3                              RxBuf[6] = 0;
 328   3                              EA               = 0;
 329   3                              PWMCKS   = 0x10;
 330   3                              T2L              = 0xEB;
 331   3                              T2H              = 0xFF;
 332   3                              PWM(960, 960, 960, 960);
 333   3                              Delay(60000);           //У׼ϵһ
 334   3                              PWM(1000, 1000, 1000, 1000);
 335   3                              PWMCKS   = 0x00;
 336   3                              EA               = 1;
 337   3                              i                = 0;
 338   3                      }
 339   2      
 340   2                      //ڷ  λȡעͱ䣡עͱΪ˼Сңʱ
 341   2                      //Send(ich1,ich2,ich3,ich4,ich5,ich6);
 342   2              }
 343   1      }
 344          
 345          
*** ERROR C249 IN LINE 345 OF USR\MAIN.C: 'DATA': SEGMENT TOO LARGE

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
