C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\bin\main.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE usr\main.c BROWSE INCDIR(.\usr) DEBUG OBJECTEXTEND PRINT(.\listing\main.lst
                    -) OBJECT(.\bin\main.obj)

line level    source

   1          /**************************************************************************
   2           *
   3           *   Copyright (c) 2016 www.bjfz.cc. All rights reserved.
   4           *
   5           * @file main.c
   6           *
   7           * Ö÷³ÌĞò
   8           *
   9           * @author Author email
  10           *
  11           *************************************************************************/
  12          
  13          
  14          //*************************************2015Äê2ÔÂ14ÈÕ Öø*********************
  15          //Ó²¼ş²ÎÊı£º
  16          //µç³Ø:1S/3.7Vµç³Ø ÍÆ¼ö300-650mAh×óÓÒ   500mahÒÔÉÏµÄµç³ØÍÆ¼ö°²×°ÔÚ±³Ãæ
  17          //µç»ú/½°:720¿ÕĞÄ±­/59MM½°
  18          //   ÌØ±ğÉùÃ÷£º±¾³ÌĞò²âÊÔµÄ¿ÕĞÄ±­ÎªÌÔ±¦µêÆÌ ÉîÛÚ½ÜÊ¢µç»ú µÄ720¿ÕĞÄ±­ ÆäËû³§¼ÒµÄµç»ú²»ÊÊÓÃÓÚ±¾³ÌĞò£¬³ı·Ç×ÔĞ
             -Ğµ÷ÕûPID
  19          //             ±¾³ÌĞò²âÊÔµÄÂİĞı½°ÎªÌÔ±¦µêÆÌ »¢»¢Æ½¼Ûµê µÄ59MMÖ±¾¶ 1mm¿×¾¶ÂİĞı½° ÆäËû³§¼ÒµÄÂİĞı½°²»ÊÊÓÃÓÚ±¾
             -³ÌĞò£¬³ı·Ç×ÔĞĞµ÷ÕûPID
  20          //MCU IAP15W4K61S4@28.000MHZ  (B°æ£¡A°æµ¥Æ¬»ú¾ø¶Ô²»ÊÊºÏ£¡)
  21          //ÌØ±ğËµÃ÷£¬±¾³ÌĞòÄ¿Ç°Ö»ÊÊºÏIAPÏµÁĞµÄµ¥Æ¬»ú£¬·ÇIAPµ¥Æ¬»úÊ¹ÓÃĞëĞŞ¸ÄEEPROM¶ÁĞ´µØÖ·
  22          //ÍÓÂİÒÇ¼ÓËÙ¶È¼Æ£ºMPU-6050
  23          //ÎŞÏßĞ¾Æ¬:NRF24L01
  24          //µç»úÇı¶¯MOS¹Ü:AO3400
  25          //ÉıÑ¹·½°¸:BL8530
  26          //3.3VÎÈÑ¹·½°¸:ME6219C-33-M5G
  27          //ÏÂÔØ¿Ú±£»¤:1Kµç×è
  28          //»ú¼Ü³ß´ç:94mm*94mm
  29          
  30          //Éè¼ÆÊ§ÎóµÄµØ·½£º
  31          //MOS¹Ü±£»¤ÓÃµÄĞ¤ÌØ»ù·Å´íÁËÎ»ÖÃ£¬²»¹ıÍêÈ«²»Ó°ÏìÊ¹ÓÃ£¬ÕâÖÖĞ¡ËÄÖá²»¼ÓĞ¤ÌØ»ù±£»¤¶¼ĞĞ¡£
  32          
  33          //Èí¼ş²ÎÊı£º
  34          //×ËÌ¬½âËã£ºËÄÔªÊı
  35          //ÂË²¨£º»¥²¹ÂË²¨£¨From µÂ¹ú¿ªÔ´ËÄÖá£©
  36          //PID£º´®¼¶PID Íâ»·PI,ÄÚ»·PID
  37          
  38          //Êı¾İ¶¨ÒåËµÃ÷£º
  39          //data 51µ¥Æ¬»úÆ¬ÄÚRAM×îÇ°Ãæ128×Ö½ÚRAM ÓÃACC¶ÁĞ´£¬ËÙ¶È×î¿ì
  40          //idata Æ¬ÄÚRAM×îÇ°Ãæ256×Ö½ÚµÄRAM °üÀ¨data ÓÃÀàËÆÖ¸ÕëÄ£Ê½·ÃÎÊ ÊÊºÏÓÃÓÚÖ¸Õë²Ù×÷
  41          //pdata Íâ²¿À©Õ¹RAMµÄÇ°256×Ö½ÚµÄRAM ²»ÒªÓÃ »á´óÒÌÂè£¡
  42          //xdata Íâ²¿À©Õ¹RAM ÓÃDPTR·ÃÎÊ
  43          
  44          #include "timer.h"
  45          
  46          #include "app/imu.h"
  47          #include "app/stc15w4kpwm.h"
  48          
  49          #include "driver/eeprom.h"
  50          #include "driver/mpu6050.h"
  51          #include "driver/nrf24l01.h"
  52          #include "driver/usart.h"
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 2   

  53          
  54          #include "inc/common.h"
  55          
  56          #include <math.h>
  57          
  58          // ************************************************************************
  59          float XE = 0, YE = 0;            //½Ç¶ÈÈËÎªĞŞÕı£¬µ«ÊÇËÄÖáÆ¯ÒÆÒ»°ãÊÇÓ²¼şÔì³ÉµÄ£¬¹Ê²»½«´ËÖµĞ´ÈëEEPROM£¬Õâ¸öÖ
             -»ÊÇÓ¦¼±Ê¹ÓÃ£¬·¢ÏÖÆ¯ÒÆÓ¦
  60          //Á¬ÖÁÉÏÎ»»ú¼ì²éµç»úÖáÊÇ·ñ·¢ÉúÍäÇú£¬·¢ÏÖÎÊÌâµç»ú¼°Ê±¸ü»»
  61          
  62          // ÓÍÃÅ±ä»¯ËÙ¶È¿ØÖÆ£¬²»ÕâÑù×öµÄ»°¿ìËÙ±ä»¯ÓÍÃÅÊ±ËÄÖá»áÊ§ËÙ·­×ª²¢GG
  63          float throttle = 0;
  64          
  65          // ÎŞÏß´®¿Ú/´®¿ÚÏà¹Ø
  66          uint8_t ich1 = 0, ich2 = 0, ich3 = 0, ich4 = 0, ich5 = 0, ich6 = 0;
  67          
  68          // µç»úËÙ¶È²ÎÊı
  69          int speed0 = 0, speed1 = 0, speed2 = 0, speed3 = 0, V = 0;
  70          int PWM0 = 0, PWM1 = 0, PWM2 = 0, PWM3 = 0; //¼ÓÔØÖÁPWMÄ£¿éµÄ²ÎÊı
  71          int g_x = 0, g_y = 0, g_z = 0;    //ÍÓÂİÒÇ½ÃÕı²ÎÊı
  72          char a_x = 0, a_y = 0;            //½Ç¶È½ÃÕı²ÎÊı
  73          /* unsigned char TxBuf[20] = {0}; */
  74          uint8_t RxBuf[20] = {0};
  75          
  76          double PID_x = 0, PID_y = 0, PID_z = 0; //PID×îÖÕÊä³öÁ¿
  77          float FR1 = 0, FR2 = 0, FR3 = 0; //½«charÊı¾İ×ª´æÎªfloatĞÍ
  78          
  79          //*****************½Ç¶È²ÎÊı*************************************************
  80          double  Gyro_y     = 0, Gyro_x = 0, Gyro_z = 0; //YÖáÍÓÂİÒÇÊı¾İÔİ´æ
  81          double  Accel_x    = 0, Accel_y = 0, Accel_z = 0;       //XÖá¼ÓËÙ¶ÈÖµÔİ´æ
  82          double  Angle_ax   = 0, Angle_ay = 0, Angle_az = 0;     //ÓÉ¼ÓËÙ¶È¼ÆËãµÄ¼ÓËÙ¶È(»¡¶ÈÖÆ)
  83          double  Angle_gy   = 0, Angle_gx = 0, Angle_gz = 0;     //ÓÉ½ÇËÙ¶È¼ÆËãµÄ½ÇËÙÂÊ(½Ç¶ÈÖÆ)
  84          double  AngleAx    = 0, AngleAy = 0;    //Èı½Çº¯Êı½âËã³öµÄÅ·À­½Ç
  85          double  Angle      = 0, Angley = 0;     //ËÄÔªÊı½âËã³öµÄÅ·À­½Ç
  86          double  Anglezlate = 0;         //ZÖáÏà¹Ø
  87          double  Ax                 = 0, Ay = 0; //¼ÓÈëÒ£¿ØÆ÷¿ØÖÆÁ¿ºóµÄ½Ç¶È
  88          
  89          //****************×ËÌ¬´¦ÀíºÍPID*********************************************
  90          float Out_PID_X = 0, Last_Angle_gx = 0; //Íâ»·PIÊä³öÁ¿  ÉÏÒ»´ÎÍÓÂİÒÇÊı¾İ
  91          float Out_XP = 35, Out_XI = 0.01, ERRORX_Out = 0; //Íâ»·P  Íâ»·I  Íâ»·Îó²î»ı·Ö
  92          //ÄÚ»·P  ÄÚ»·I   ÄÚ»·D  ÄÚ»·Îó²î»ı·Ö
  93          float In_XP = 0.4, In_XI = 0.01, In_XD = 9, ERRORX_In = 0; 
  94          
  95          float Out_PID_Y = 0, Last_Angle_gy = 0;
  96          float Out_YP = 35, Out_YI = 0.01, ERRORY_Out = 0;
  97          float In_YP = 0.4, In_YI = 0.01, In_YD = 9, ERRORY_In = 0;
  98          
  99          float ZP = 5.0, ZD = 4.0; //×ÔĞı¿ØÖÆµÄP D
 100          
 101          int16_t lastR0 = 0, ZT = 0; //ÉÏÒ»´ÎRxBuf[0]Êı¾İ(RxBuf[0]Êı¾İÔÚ²»¶Ï±ä¶¯µÄ)   ×´Ì¬±êÊ¶
 102          int16_t i = 0;
 103          
 104          void Angle_Calculate() interrupt 1
 105          {
 106   1              // ·ÀÖ¹ÓÍÃÅ±ä»¯¹ı¿ì¶øÊ§ËÙ
 107   1              if (throttle<RxBuf[4]&&(RxBuf[4]-throttle) <= 2) {
 108   2                      throttle++;
 109   2                      throttle++;
 110   2              } else if (throttle>RxBuf[4]&&(throttle-RxBuf[4]) <= 2) {
 111   2                      throttle--;
 112   2                      throttle--;
 113   2              } else {
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 3   

 114   2                      throttle = RxBuf[4];
 115   2              }
 116   1      
 117   1              if (RxBuf[1] > FR1) {
 118   2                      FR1 += 0.2;
 119   2              } else if (RxBuf[1] < FR1) {
 120   2                      FR1 -= 0.2;
 121   2              }
 122   1      
 123   1              if (RxBuf[2] > FR2) {
 124   2                      FR2 += 0.2;
 125   2              } else if (RxBuf[2] < FR2) {
 126   2                      FR2 -= 0.2;
 127   2              }
 128   1      
 129   1              throttle = (float)RxBuf[4] * 3 / 4;
 130   1      
 131   1              if (throttle > 100) { //Èç¹ûÓÍÃÅ´óÓÚ100 ¼´¿ªÊ¼Æğ·É
 132   2                      if (RxBuf[0] == lastR0) { //Èç¹ûRxBuf[0]µÄÊı¾İÃ»ÓĞÊÕµ½ ¼´Ê¸Áª
 133   3                              ZT++;  //×´Ì¬±êÊ¶+1
 134   3      
 135   3                              if (ZT > 128) {
 136   4                                      ZT = 128;   //×´Ì¬±êÊ¶´óÓÚ128¼´1ÃëÃ»ÓĞÊÕµ½Êı¾İ£¬Ê§¿Ø±£»¤
 137   4                              }
 138   3                      } else {
 139   3                              ZT = 0;
 140   3                      }
 141   2              } else {
 142   2                      ZT = 0;   //ÊÕµ½ĞÅºÅÍË³öÊ§¿Ø±£»¤
 143   2              }
 144   1      
 145   1              if (ZT == 128) {
 146   2                      throttle = 101;    //´¥·¢Ê§¿Ø±£»¤ ÓÍÃÅÎª1°ëÉÙÒ»µã£¬»ºÂıÏÂ½µ£¬¸©Ñöºá¹ö·½Ïò¶æ¹éÖĞ
 147   2                      RxBuf[1] = 128;
 148   2                      RxBuf[2] = 128;
 149   2              }
 150   1      
 151   1              lastR0 = RxBuf[0];
 152   1              i++;
 153   1      
 154   1              if (i == 130) {
 155   2                      i = 129;
 156   2              }
 157   1      
 158   1              Accel_y = GetData(ACCEL_YOUT_H);        //¶ÁÈ¡6050Êı¾İ
 159   1              Accel_x = GetData(ACCEL_XOUT_H);
 160   1              Accel_z = GetData(ACCEL_ZOUT_H);
 161   1              Gyro_x  = GetData(GYRO_XOUT_H) - g_x;
 162   1              Gyro_y  = GetData(GYRO_YOUT_H) - g_y;
 163   1              Gyro_z  = GetData(GYRO_ZOUT_H) - g_z;
 164   1      
 165   1              Last_Angle_gx = Angle_gx; //´¢´æÉÏÒ»´Î½ÇËÙ¶ÈÊı¾İ
 166   1              Last_Angle_gy = Angle_gy;
 167   1              Angle_ax = (Accel_x)    / 8192; //¼ÓËÙ¶È´¦Àí
 168   1              Angle_az = (Accel_z)    / 8192; //¼ÓËÙ¶ÈÁ¿³Ì +-4g/S
 169   1              Angle_ay = (Accel_y)    / 8192; //×ª»»¹ØÏµ8192LSB/g
 170   1              Angle_gx = (Gyro_x)             / 65.5; //ÍÓÂİÒÇ´¦Àí
 171   1              Angle_gy = (Gyro_y)             / 65.5; //ÍÓÂİÒÇÁ¿³Ì +-500¶È/S
 172   1              Angle_gz = (Gyro_z)             / 65.5; //×ª»»¹ØÏµ65.5LSB/¶È
 173   1              //***********************************ËÄÔªÊı½âËã**************************
 174   1              // 0.174533ÎªPI/180 Ä¿µÄÊÇ½«½Ç¶È×ª»¡¶È
 175   1              IMUupdate(deg2rad(Angle_gx), deg2rad(Angle_gy), deg2rad(Angle_gz),
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 4   

 176   1                                Angle_ax, Angle_ay, Angle_az);
 177   1      
 178   1              //********************Èı½Çº¯ÊıÖ±½Ó½âËãÒÔ¹©±È½ÏËÄÔªÊı½âËã¾«×¼¶È*****************
 179   1              // ºóÃæµÄÊı×ÖÊÇ180/PI Ä¿µÄÊÇ»¡¶È×ª½Ç¶È
 180   1              AngleAx = rad2deg(atan(Angle_ax / sqrt(sq(Angle_ay) + sq(Angle_az))));
 181   1              AngleAy = rad2deg(atan(Angle_ay / sqrt(sq(Angle_ax) + sq(Angle_az))));
 182   1      
 183   1              //**************XÖáÖ¸Ïò*************************************************
 184   1              FR1 = ((fp32)RxBuf[1] - 128) / 7;//charÀàĞÍ×ª´æÎªfloatÒÔ±ã³ı·¨ÔËËã
 185   1              Ax = Angle - FR1 - a_x;                 //½Ç¶È¿ØÖÆÁ¿¼ÓÔØÖÁ½Ç¶È
 186   1      
 187   1              if (throttle > 20) {
 188   2                      ERRORX_Out += Ax;                       //Íâ»·»ı·Ö(ÓÍÃÅĞ¡ÓÚÄ³¸öÖµÊ±²»»ı·Ö)
 189   2              } else {
 190   2                      ERRORX_Out = 0;                         //ÓÍÃÅĞ¡ÓÚ¶¨ÖµÊ±Çå³ı»ı·ÖÖµ
 191   2              }
 192   1      
 193   1              /* »ı·ÖÏŞ·ù */
 194   1              ERRORX_Out = constraint(ERRORX_Out, -500, 500);
 195   1              Out_PID_X = Ax*Out_XP + ERRORX_Out*Out_XI; //Íâ»·PI
 196   1      
 197   1              if (throttle > 20) {
 198   2                      ERRORX_In += (Angle_gy - Out_PID_X); //ÄÚ»·»ı·Ö(ÓÍÃÅĞ¡ÓÚÄ³¸öÖµÊ±²»»ı·Ö)
 199   2              } else {
 200   2                      ERRORX_In = 0; //ÓÍÃÅĞ¡ÓÚ¶¨ÖµÊ±Çå³ı»ı·ÖÖµ
 201   2              }
 202   1      
 203   1              /* ÄÚ»·»ı·ÖÏŞ·ù */
 204   1              ERRORX_In = constraint(ERRORX_In, -500, 500);
 205   1              /* ÄÚ»·PID¼ÆËã */
 206   1              PID_x = (Angle_gy + Out_PID_X) * In_XP +
 207   1                      ERRORX_In * In_XI +
 208   1                      (Angle_gy - Last_Angle_gy) * In_XD;
 209   1              /* PIDÏŞ·ùĞŞÕı */
 210   1              PID_x = constraint(PID_x, -1000, 1000);
 211   1      
 212   1              speed0 = 0 - PID_x;
 213   1              speed2 = 0 + PID_x;
 214   1      
 215   1              //**************YÖáÖ¸Ïò*************************************************
 216   1              /* ´¦ÀíYÖáÖĞ¼äËÀÇø·¶Î§£º113~143£¬Æä×î´óÈ¡Öµ·¶Î§Îª0~255 */
 217   1              if (RxBuf[2] >= 113 && RxBuf[2] <= 143) {
 218   2                      RxBuf[2] = 128;
 219   2              }
 220   1      
 221   1              // charÀàĞÍ×ª´æÎªfloatÒÔ±ã³ı·¨ÔËËã
 222   1              FR2 = ((fp32)RxBuf[2] - 128) / 7.0;
 223   1              Ay = Angley + FR2 - a_y; //½Ç¶È¿ØÖÆÁ¿¼ÓÔØÖÁ½Ç¶È
 224   1      
 225   1      
 226   1              if (throttle > 20) {
 227   2                      ERRORY_Out += Ay; //Íâ»·»ı·Ö(ÓÍÃÅĞ¡ÓÚÄ³¸öÖµÊ±²»»ı·Ö)
 228   2              } else {
 229   2                      ERRORY_Out = 0; //ÓÍÃÅĞ¡ÓÚ¶¨ÖµÊ±Çå³ı»ı·ÖÖµ
 230   2              }
 231   1      
 232   1              /* YÖáÍâ»·Îó²îÏŞ·ù */
 233   1              ERRORY_Out = constraint(ERRORY_Out, -500, 500);
 234   1              Out_PID_Y = Ay * Out_YP + ERRORY_Out * Out_YI; //Íâ»·PI
 235   1      
 236   1              if (throttle > 20) {
 237   2                      ERRORY_In += (Angle_gx - Out_PID_Y); //ÄÚ»·»ı·Ö(ÓÍÃÅĞ¡ÓÚÄ³¸öÖµÊ±²»»ı·Ö)
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 5   

 238   2              } else {
 239   2                      ERRORY_In = 0; //ÓÍÃÅĞ¡ÓÚ¶¨ÖµÊ±Çå³ı»ı·ÖÖµ
 240   2              }
 241   1      
 242   1              /* YÖáÄÚ»·Îó²îÏŞ·ù */
 243   1              ERRORY_In = constraint(ERRORY_In, -500, 500);
 244   1              /* ÄÚ»·PID */
 245   1              PID_y = (Angle_gx + Out_PID_Y) * In_YP +
 246   1                      ERRORY_In * In_YI +
 247   1                      (Angle_gx - Last_Angle_gx) * In_YD;
 248   1      
 249   1              PID_y = constraint(PID_y, -1000, 1000);
 250   1      
 251   1              speed3 = 0 + PID_y;
 252   1              speed1 = 0 - PID_y; //¼ÓÔØµ½ËÙ¶È²ÎÊı
 253   1      
 254   1              //**************ZÖáÖ¸Ïò(ZÖáËæ±ãÀ²£¬×ÔĞı¿ØÖÆÃ»±ØÒªÉÏ´®¼¶PID)*******************
 255   1              FR3 = ((float)RxBuf[3] - 128) * 1.5;
 256   1              Angle_gz -= FR3;
 257   1              PID_z = (Angle_gz) * ZP + (Angle_gz - Anglezlate) * ZD;
 258   1              Anglezlate = Angle_gz;
 259   1              speed0 = speed0 + PID_z;
 260   1              speed2 = speed2 + PID_z;
 261   1              speed1 = speed1 - PID_z;
 262   1              speed3 = speed3 - PID_z;
 263   1      
 264   1              //*****************´®¿Ú¼°ÎŞÏß´®¿ÚÏà¹Ø*************************************
 265   1              // ´Ë´¦¿É·¢ËÍ6¸öÊı¾İÖÁÉÏÎ»»ú£¬ĞèÒª·¢ËÍÊ²Ã´Êı¾İÔÚ´Ë´¦ĞŞ¸Ä¼´¿É
 266   1              ich1 = Ax;
 267   1              ich2 = Ay;
 268   1              ich3 = AngleAx;
 269   1              ich4 = AngleAy;
 270   1              ich5 = 0;
 271   1              ich6 = 0;
 272   1      
 273   1              //**************½«ËÙ¶È²ÎÊı¼ÓÔØÖÁPWMÄ£¿é************************************
 274   1              //ËÙ¶È²ÎÊı¿ØÖÆ£¬·ÀÖ¹³¬¹ıPWM²ÎÊı·¶Î§0-1000
 275   1              PWM0 = (1000 - throttle * 4 + speed0);
 276   1              PWM0 = constraint(PWM0, 0, 1000);
 277   1      
 278   1              PWM1 = (1000 - throttle * 4 + speed1);
 279   1              PWM1 = constraint(PWM1, 0, 1000);
 280   1      
 281   1              PWM2 = (1000 - throttle * 4 + speed2);
 282   1              PWM2 = constraint(PWM0, 0, 1000);
 283   1      
 284   1              PWM3 = (1000 - throttle * 4 + speed3);
 285   1              PWM3 = constraint(PWM3, 0, 1000);
 286   1      
 287   1              if (throttle >= 10) {
 288   2                      PWM(PWM1, PWM2, PWM0, PWM3);   //1203
 289   2              } else {
 290   2                      PWM(1000, 1000, 1000, 1000);
 291   2              }
 292   1      }
 293          
 294          void main()
 295          {
 296   1              PWMGO();//³õÊ¼»¯PWM
 297   1              IAPRead();//¶ÁÈ¡ÍÓÂİÒÇ¾²²î
 298   1              InitMPU6050();//³õÊ¼»¯MPU-6050
 299   1              Usart_Init();//³õÊ¼»¯´®¿Ú
C51 COMPILER V9.00   MAIN                                                                  05/12/2016 16:55:54 PAGE 6   

 300   1              timer0_init();//³õÊ¼»¯¶¨Ê±Æ÷
 301   1              RxBuf[1] = 128;
 302   1              RxBuf[2] = 128;
 303   1              RxBuf[3] = 128;
 304   1              RxBuf[4] = 0;
 305   1      
 306   1              while (1) {
 307   2                      Delay(500);
 308   2                      nRF24L01_RxPacket(RxBuf);
 309   2      
 310   2                      if (RxBuf[5] == 1 && i > 128) {
 311   3                              IAP_Gyro();
 312   3                              RxBuf[5] = 0;
 313   3                              EA               = 0;
 314   3                              PWMCKS   = 0x10;
 315   3                              T2L              = 0xEB;
 316   3                              T2H              = 0xFF;
 317   3                              PWM(960, 960, 960, 960);
 318   3                              Delay(60000);           //Ğ£×¼Íê±ÏµÎÒ»Éù
 319   3                              PWM(1000, 1000, 1000, 1000);
 320   3                              PWMCKS   = 0x00;
 321   3                              EA               = 1;
 322   3                              i                = 0;
 323   3                      }
 324   2      
 325   2                      if (RxBuf[6] == 1 && i > 128) {
 326   3                              IAP_Angle();
 327   3                              RxBuf[6] = 0;
 328   3                              EA               = 0;
 329   3                              PWMCKS   = 0x10;
 330   3                              T2L              = 0xEB;
 331   3                              T2H              = 0xFF;
 332   3                              PWM(960, 960, 960, 960);
 333   3                              Delay(60000);           //Ğ£×¼Íê±ÏµÎÒ»Éù
 334   3                              PWM(1000, 1000, 1000, 1000);
 335   3                              PWMCKS   = 0x00;
 336   3                              EA               = 1;
 337   3                              i                = 0;
 338   3                      }
 339   2      
 340   2                      //´®¿Ú·¢ËÍÊı¾İ  ÈçĞèÁ¬½ÓÉÏÎ»»ú£¬ĞëÈ¡Ïû×¢ÊÍ±¾¾ä£¡£¡£¡×¢ÊÍ±¾¾äÊÇÎªÁË¼õĞ¡Ò£¿ØÑÓÊ±
 341   2                      //Send(ich1,ich2,ich3,ich4,ich5,ich6);
 342   2              }
 343   1      }
 344          
 345          
*** ERROR C249 IN LINE 345 OF USR\MAIN.C: 'DATA': SEGMENT TOO LARGE

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
